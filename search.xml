<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS按位操作符]]></title>
    <url>%2F2019%2F08%2F21%2FJS%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JS按位操作符（Bitwise operators）做什么的？将其操作数（operands）当作 32位的比特序列（由0和1组成）, 按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。 所有的按位操作符的操作数都会被转成补码（two’s complement）形式的有符号32位整数。 32位的比特序列 ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。在 ECMAScript 中，所有整数字面量默认都是有符号整数; 有符号整数使用 31 位表示整数的数值 （数值位），用第 32 位表示整数的符号 （符号位），0 表示正数，1 表示负数。 原码/反码/补码 123456789101112131415/* * 正数的原码/反码/补码 一致 * 负数的原码：其绝对值的原码符号位取反（0-&gt;1, 1-&gt;0） * 负数的反码：其绝对值的原码整体取反 * 负数的补码：其绝对值的原码整体取反后+1 * */ 18 （base 10） 原/反/补 码：000000000000000000000000010010 -18（base 10） 原码：100000000000000000000000010010 反码：111111111111111111111111101101 补码：111111111111111111111111101110 优劣势 直接对二进制数值进行运算，属于较为底层的运算，运算速度快，但是同样，可读性差 家庭成员123456789101112131415按位操作符│├─ 按位逻辑操作符│ ││ ├─ 按位与 &amp;│ ├─ 按位或 |│ ├─ 按位非 ~│ └─ 按位异或 ^│└─ 按位移动操作符 │ ├─ 左移 &lt;&lt; ├─ 有符号右移 &gt;&gt; └─ 无符号右移 &gt;&gt;&gt; 按位逻辑操作符操作规则： 操作数被转换成32位整数，用比特序列（0和1组成）表示，超过32位的数字会被丢弃。 第一个操作数的每个比特位与第二个操作数的相应比特位匹配，逐位运算 按位与 &amp;规则：1/1得1，否则为0 123456// 1的二进制表示为: 00000000 00000000 00000000 00000001// 3的二进制表示为: 00000000 00000000 00000000 00000011------------------------------------------------------ =&gt; 00000000 00000000 00000000 00000001console.log(1 &amp; 3) // 1 按位或 |规则：0/0得0，否则为1 123456// 1的二进制表示为: 00000000 00000000 00000000 00000001// 3的二进制表示为: 00000000 00000000 00000000 00000011------------------------------------------------------ =&gt; 00000000 00000000 00000000 00000011console.log(1 | 3) // 3 按位非 ~规则：0 -&gt; 1, 1 -&gt; 0 1234567// -1的二进制表示为: 11111111 11111111 11111111 11111111------------------------------------------------------ =&gt; 00000000 00000000 00000000 00000000console.log(~ -1) // 0- (x + 1) 按位异或 ^规则：相同得0，不同得1 123456// 1的二进制表示为: 00000000 00000000 00000000 00000001// 3的二进制表示为: 00000000 00000000 00000000 00000011------------------------------------------------------ =&gt; 00000000 00000000 00000000 00000010console.log(1 ^ 3) // 2 按位移动操作符操作规则： 两个操作数，第一个是被移动的数字，第二个是移动的长度 左移 &lt;&lt;规则：将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充，符号位保留 123459 (base 10): 00000000000000000000000000001001 (base 2) --------------------------------9 &lt;&lt; 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)// x &lt;&lt; y =&gt; x * (2 ** y) 有符号右移 &gt;&gt;规则：将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。 12345678910// 9 &gt;&gt; 29 (base 10): 00000000000000000000000000001001 (base 2) --------------------------------9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)// -9 &gt;&gt; 2-9 (base 10): 11111111111111111111111111110111 (base 2) ---------------------------------9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10) 无符号右移 &gt;&gt;&gt;规则：将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。即便右移 0 个比特，结果也是非负的。 1234567891011//对于非负数，&gt;&gt; 和 &gt;&gt;&gt; 结果一致// 9 &gt;&gt;&gt; 2 9 (base 10): 00000000000000000000000000001001 (base 2) --------------------------------9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)// -9 &gt;&gt;&gt; 2-9 (base 10): 11111111111111111111111111110111 (base 2) ---------------------------------9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10) 用途 &amp; 判断奇偶 1234// n &amp; 1 = 0 ，n为偶数// n &amp; 1 = 1 ，n为奇数1 (base 10): 00000000000000000000000000000001 (base 2) ~, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt;, | 取整 12345678910console.log(~~ 9.99) // 9 -(-(x + 1) + 1)console.log(9.99 &lt;&lt; 0) // 9console.log(9.99 &gt;&gt; 0) // 9// &gt;&gt;&gt;不可对负数取整console.log(9.99 &gt;&gt;&gt; 0) // 9console.log(9.99 | 0) // 90 (base 10): 00000000000000000000000000000000 (base 2)// | 有1得1，否则为0 (有坑！！！) &gt;&gt;&gt; 判断正负 1x === x &gt;&gt;&gt; 0 // true 非负数 ^ 交换变量值 123456789101112131415161718192021let a = 5let b = 8a ^= bb ^= aa ^= bconsole.log(a) // 8console.log(b) // 5a (base 10): 00000000000000000000000000000101 (base 2)b (base 10): 00000000000000000000000000001000 (base 2)a = a ^ b-------------------------------------------------------a (base 10): 00000000000000000000000000001101 (base 2)b (base 10): 00000000000000000000000000001000 (base 2)b = b ^ a-------------------------------------------------------b (base 10): 00000000000000000000000000000101 (base 2)a (base 10): 00000000000000000000000000001101 (base 2)a = a ^ b-------------------------------------------------------a (base 10): 00000000000000000000000000001000 (base 2)]]></content>
      <tags>
        <tag>语言</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习-基于v16.7.0]]></title>
    <url>%2F2018%2F12%2F25%2FReact%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8Ev16-7-0%2F</url>
    <content type="text"><![CDATA[概述React 起源于 Facebook 的内部项目，并于2013年5月开源。更多精彩见React 官网 声明式渲染先来说明一下命令式编程和声明式编程：命令式编程关注怎么做，通俗点说就是我们通过一行一行代码让机器照着一步一步的去做。例如我有一个数组，然后想通过它得到每个值都是它的值两倍的数组： const originArr = [1,2,3]; // 原始数组 const resultArr = []; // 定义一个空数组 for(let i = 0;i &lt; originArr.length;i++){ // 遍历原始数组，然后将每个值乘于2之后添加到空数组中 resultArr.push(originArr[i] * 2) } 声明式编程关注做什么，就是我们的目的。同样的例子适用声明式编程： const originArr = [1,2,3]; // 原始数组 const resultArr = originArr.map(item =&gt; item * 2); // 遍历数组由map方法代为实现，而我们只需要关注我们要做什么：即把每个值乘于2 那么react的声明式渲染体现在什么地方呢？简单点说就是react独创的JSX语法，一种把html和js结合起来的成果，例如： const title = &lt;h3&gt;This is a title&lt;/h3&gt; ; 上述代码中&lt;h3&gt;This is a title&lt;/h3&gt; 既非html也非字符串，我们可以叫它react element，实际上它在被react渲染成真实DOM之前只是一个普通的js对象，后面会有介绍。React使用JSX语法让我们只需要是关注我们想要做什么，输入的state或者props，输出的UI界面，而不用分心关注于原生的DOM操作。 组件化在React中一切皆组件，组件是React中最基本的单元结构。大到整个页面，小到一个按钮或者弹窗都可以成为一个组件。 可移植性强React不仅可以在web端使用，它还可以借助nodejs在server端渲染，还可以借助 React Native 开发移动端应用。 使用ReactReact并不强制开发者在项目中完全使用或者完全不用，所以我们可是尝试性的在项目的某个部分使用React，也可以完整的使用React完成项目。 局部使用React可以在html中通过script标签引入react框架的CDN链接： &lt;script src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot; crossorigin&gt;&lt;/script&gt; 这是React官方给出的CDN 链接，考虑到网络问题，我们可以自由选择其他的可靠资源，或者下载之后上传并使用自己的CDN服务。完整的Demo请参考 局部使用React 如果想使用JSX，需要额外引入，详情请见引入JSX 完整使用React基于React的框架也有不少，下面这几个是官方推荐使用的： 创建一个SPA，使用Create React App 如果想使用react+nodejs创建后端渲染（SSR）应用，可以使用Next.js 创建一个静态页面网站，可以使用Gatsby npx create-react-app my-app cd my-app npm start 可以通过上面的命令行完成使用creat react app来创建一个react 应用。 JSX语法const el = ( &lt;div className=&quot;box&quot; customizeProp=&quot;test&quot;&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt; ) const el = React.createElement( &apos;div&apos;, {className: &apos;box&apos;,customizeProp:&apos;test&apos;}, React.createElement( &apos;button&apos;, {onClick:handleClick}, &apos;Click me&apos; ) ); 点语法： const MyComponents = { DatePicker: function DatePicker(props) { return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;; } } function BlueDatePicker() { return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;; } 展开符属性写法： function App2() { const props = {firstName: &apos;Ben&apos;, lastName: &apos;Hector&apos;}; return &lt;Greeting {...props} /&gt;; } react lazy loadconst OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;)); &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; // 组件加载过程中出现，类似传统loading效果 &lt;section&gt; &lt;OtherComponent /&gt; &lt;/section&gt; &lt;/Suspense&gt; &lt;/div&gt; context定义： const MyContext = React.createContext(defaultValue); 使用： 父组件或者以上： &lt;MyContext.Provider value={theme}&gt; &lt;ThemedButton changeTheme={this.toggleTheme} /&gt; &lt;/MyContext.Provider&gt; 子组件： class ThemedButton extends React.Component { static contextType = MyContext; // 1 与3的点操作符方式二选一 render() { let props = this.props; let theme = this.context; // 2 return ( &lt;button {...props} style={{backgroundColor: theme.background}} /&gt; ); // 或者不使用1&amp;2或3&amp;2，使用Consumer，如果在一个组件里想使用多个context，只能使用Consumer+Provider，进行层层包裹 &lt;MyContext.Consumer&gt; {(theme) =&gt; ( &lt;button {...props} style={{backgroundColor: theme.background}} /&gt; )} &lt;/MyContext.Consumer&gt; } } ThemedButton.contextType = MyContext; // 3 export default ThemedButton; error boundaryclass ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // 1 // Update state so the next render will show the fallback UI. return { hasError: true }; } componentDidCatch(error, info) { // 2 // You can also log the error to an error reporting service logErrorToMyService(error, info); } render() { if (this.state.hasError) { // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; } return this.props.children; } } 如果有1或者2或者同时存在，则为error boundary组件，用法如下： &lt;ErrorBoundary&gt; &lt;Children /&gt; &lt;/ErrorBoundary&gt; error boundary比较类似try{}catch(){}中catch代码块，另外需要注意的是只有class组件可以成为error boundary，函数组件是不行的，这主要是因为函数组件是不支持组件自有的state特性的。error boundary几乎可以捕捉到它的子组件任何地方和任何时候的错误，但下列情况的错误是捕捉不到的： 事件处理函数中错误（可以考虑使用try/catch进行错误捕捉） 异步代码中错误 后端渲染部分的错误 以及error boundary自身的报错 ref的传递创建一个组件FancyButton，如果我们想要通过ref访问他的自组件button， 1. 通过createRef创建一个ref 2. 将ref放入FancyButton的ref属性中 3. FancyButton通过React.forwardRef将ref传递至button 4. 此时当我们访问ref.current时将指向button const FancyButton = React.forwardRef((props, ref) =&gt; ( // 此处可使用function name(){}来代替匿名函数，以实现自定义函数名称 &lt;button ref={ref} className=&quot;FancyButton&quot;&gt; {props.children} &lt;/button&gt; )); You can now get a ref directly to the DOM button: const ref = React.createRef(); &lt;FancyButton ref={ref}&gt; Click me! &lt;/FancyButton&gt;; 在高阶组件中传递ref： function logProps(Component) { class LogProps extends React.Component { componentDidUpdate(prevProps) { console.log(&apos;old props:&apos;, prevProps); console.log(&apos;new props:&apos;, this.props); } render() { const {forwardedRef, ...rest} = this.props; // Assign the custom prop &quot;forwardedRef&quot; as a ref return &lt;Component ref={forwardedRef} {...rest} /&gt;; } } // Note the second param &quot;ref&quot; provided by React.forwardRef. // We can pass it along to LogProps as a regular prop, e.g. &quot;forwardedRef&quot; // And it can then be attached to the Component. return React.forwardRef((props, ref) =&gt; { return &lt;LogProps {...props} forwardedRef={ref} /&gt;; }); } Fragments 可以单独从react中引用：import {Fragment} from ‘react’ 也可以不单独引用， &lt;React.Fragment&gt;&lt;Children /&gt;&lt;/React.Fragment&gt; 还可以使用简写语法 &lt;&gt;&lt;Children /&gt;&lt;/&gt; 渲染出的结果将会是单纯的&lt;Children /&gt;,而不存在任何父元素 HOC（高阶组件）定义： 一个函数，接受一个react组件作为参数，并且返回一个react组件，这个函数就称为高阶组件，高阶组件是一个纯函数，他不会改变作为参数的组件 function logProps(WrappedComponent) { return class extends React.Component { componentWillReceiveProps(nextProps) { console.log(&apos;Current props: &apos;, this.props); console.log(&apos;Next props: &apos;, nextProps); } render() { // Wraps the input component in a container, without mutating it. Good! return &lt;WrappedComponent {...this.props} /&gt;; } } }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>Js框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub构建个人博客]]></title>
    <url>%2F2018%2F11%2F29%2FHexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作先决：MarkDown]]></title>
    <url>%2F2018%2F11%2F29%2FHexo%E5%86%99%E4%BD%9C%E5%88%A9%E5%99%A8-MarkDown%2F</url>
    <content type="text"><![CDATA[概述MarkDown 致力于使阅读和创作文档变得容易,视可读性为最高准则，基于此，MarkDown完全由标点符号组成。 与HTML混合使用MarkDown 仅对应一小部分HTML标签，对于其未包含的标签，可以直接使用HTML。 注意事项 在 MarkDown 中HTML的块级元素应该另起一行，并且顶格写。 HTML的块级元素中的 MarkDown 语句不会生效。 HTML的内联元素没有上述两条限制 字符表现方式简洁所谓字符表现方式简洁，是指不用像在HTML中把 &amp; 写成 &amp;amp; 转义字符一样。在 MarkDown 中，随心所欲的写各种字符即可。 块级元素段落与换行一个或者多个空行（可含space）可实现段落划分；使用硬换行实现换行，即Enter键换行；&lt;br/&gt; 换行在 MarkDown 行不通。 标题Setext 样式标题Setext样式在标题下使用等于号来表示一级标题，渲染h1标签；在标题下使用连字符来表示二级标题，渲染成h2标签，如下 这是一个 H1 ============= 这是一个 H2 ------------- Atx 样式标题Atx样式标题使用一个或多个（最多六个） # 开头，依次代表h1-h6，写法如下： ### 这是一个H3 块引用在 MarkDown 中使用 &gt; 创建块引用. 最好对引用文本采取强制换行并在每一行行首放一个 &gt; 。块引用可以嵌套 (例如, 块引用中包含块引用) , 只需添加额外层级的 &gt; 即可。块引用可以包含 Markdown 元素, 包括标题, 列表和代码块。 &gt; 这是一级块引用 &gt; &gt; &gt; 这是嵌套的块引用 &gt; &gt; 返回一级块引用 上面的代码可以渲染出如下的效果： 列表无序列表无序列表使用星号, 加号, 和连字符作为每一项的开头，它们可以互换。写法如下： * 项目一 * 项目二 * 项目三 + 项目一 + 项目二 + 项目三 - 项目一 - 项目二 - 项目三 有序列表有序列表以阿拉伯数字加英文句号开头，数字大小顺序并不重要，不影响渲染，渲染结果始终从1开始。写法如下： 1. 项目一 2. 项目二 3. 项目三 代码块要在 Markdown 中插入代码块, 只需要将每一行都缩进 4 个空格或者 1 个水平制表符（即一个tab），Markdown 渲染时会用 &lt;pre&gt; 和 &lt;code&gt; 标签包围代码块。写法如下： 这行是顶格写的。 这行缩进了4个空格，将会被渲染成代码块。 水平线如果一行中只有三个以上的连字符, 星号, 或者下划线则会在该位置生成一个 &lt;hr /&gt; 标签. 星号和连字符之间的空格也是允许的. * ** 有空格的3个星号 -- - 有空格的3个连字符 ___ 3个下划线 水平线的效果如下： 内联元素链接MarkDown 的链接有内联链接和引用链接两种方式，支持相对路径和绝对路径。 内联链接内联链接的优势在于字符量较少，但是劣势尤为明显，不利于阅读。其写法如下： [link display name](http://example.com/ &quot;optional title&quot;) 引用链接引用了解是将链接定义成一个id，然后由需要的地方进行引用，引用谅解利于阅读： [link display name][link id] // 引用链接,两个中括号之间可以存在空格 [link id]: http://example.com/ &quot;Optional Title Here&quot; // 定义链接，需要独占一行，可以定义同一个文件的任何地方 [link id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; // 定义链接，链接可以使用 &lt;&gt; 括起来 如果链接显示的文字和链接的id相同，可以有如下写法： [displayNameSameWithLinkId][] // 引用链接 [displayNameSameWithLinkId]: http://example.com/ &quot;Optional Title Here&quot; // 定义链接 强调MarkDown 将星号 * 和下划线 _ 作为强调标记. 用 * 或者 _ 包裹的文本将会用 HTML &lt;em&gt; 标签包裹,倾斜; 双 * 或者 _ 将会用 HTML &lt;strong&gt; 标签包裹，加粗. _单个下划线_ **双星** 代码要在MarkDown中输出一个代码片段, 需要使用重音符号 ` 。如果需要在代码中显示 ` , 则需要需要使用多个 ` 作为开始和结尾标记。写法如下： `代码` `` ` `` // 在代码中显示 ` 图片MarkDown 中的图片和链接十分相似，也分为内联和引用。但 MarkDown 图片不能指定图片大小，如需要，推荐使用 img。标签写法如下： ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) // 内联写法 // 引用写法 ![Alt text][id] // 引用图片链接 [id]: url/to/image &quot;Optional title attribute&quot; // 定义图片链接 自动链接&lt;http://example.com/&gt; 这种写法将会被 MarkDown 渲染成 &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 转义字符MarkDown 使用 \ 进行字符转义。支持如下字符进行反斜杠转义： \ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark THE END]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>文档</tag>
        <tag>语言</tag>
      </tags>
  </entry>
</search>
